#include "stm32l4xx_hal.h"
#include "i2c.h"
//#include "font_8x16.h"  // 8x16字体文件

#include "lcd_ssd1315.h"

/************************** OLED硬件配置 **************************/
#define OLED_I2C_HANDLE    &hi2c2                  // I2C2句柄（需与CubeMX生成的一致）
#define OLED_I2C_ADDR      0x3C << 1               // I2C从地址（SA0=1时为0x3C，左移1位含读写位）
#define OLED_WIDTH         128                     // OLED宽度（128列）
#define OLED_HEIGHT        64                      // OLED高度（64行，8页）

/************************** 8x8字符字模表（ASCII: 0x20~0x7E）**************************/
// 横向取模，上到下，左到右（适配128x64 OLED 8页结构）
const uint8_t OLED_Font8x8[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // 0x20 空格
    0x00,0x00,0x6F,0x6F,0x00,0x00,0x00,0x00, // 0x21 !
    0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00, // 0x22 "
    0x00,0x30,0x30,0x30,0x7C,0x30,0x30,0x00, // 0x23 #
    0x00,0x18,0x24,0x7E,0x24,0x24,0x18,0x00, // 0x24 $
    0x00,0x60,0x66,0x06,0x0C,0x18,0x60,0x00, // 0x25 %
    0x00,0x38,0x44,0x4C,0x54,0x22,0x54,0x00, // 0x26 &
    0x00,0x10,0x10,0x00,0x00,0x00,0x00,0x00, // 0x27 '
    0x00,0x08,0x10,0x20,0x20,0x10,0x08,0x00, // 0x28 (
    0x00,0x20,0x10,0x08,0x08,0x10,0x20,0x00, // 0x29 )
    0x00,0x10,0x38,0x10,0x10,0x38,0x10,0x00, // 0x2A *
    0x00,0x10,0x10,0x7C,0x10,0x10,0x00,0x00, // 0x2B +
    0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x00, // 0x2C ,
    0x00,0x10,0x10,0x10,0x10,0x10,0x00,0x00, // 0x2D -
    0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00, // 0x2E .
    0x00,0x04,0x08,0x10,0x20,0x40,0x00,0x00, // 0x2F /
    0x00,0x38,0x44,0x4C,0x54,0x64,0x38,0x00, // 0x30 0
    0x00,0x10,0x30,0x50,0x10,0x10,0x7C,0x00, // 0x31 1
    0x00,0x38,0x44,0x04,0x08,0x10,0x7C,0x00, // 0x32 2
    0x00,0x38,0x04,0x08,0x04,0x44,0x38,0x00, // 0x33 3
    0x00,0x08,0x18,0x28,0x48,0x7C,0x08,0x00, // 0x34 4
    0x00,0x7C,0x40,0x78,0x04,0x44,0x38,0x00, // 0x35 5
    0x00,0x38,0x40,0x78,0x44,0x44,0x38,0x00, // 0x36 6
    0x00,0x7C,0x04,0x08,0x10,0x10,0x10,0x00, // 0x37 7
    0x00,0x38,0x44,0x38,0x44,0x44,0x38,0x00, // 0x38 8
    0x00,0x38,0x44,0x44,0x3C,0x04,0x38,0x00, // 0x39 9
    0x00,0x00,0x10,0x00,0x00,0x10,0x00,0x00, // 0x3A :
    0x00,0x00,0x10,0x00,0x00,0x10,0x08,0x00, // 0x3B ;
    0x00,0x10,0x20,0x40,0x20,0x10,0x00,0x00, // 0x3C <
    0x00,0x20,0x20,0x20,0x20,0x20,0x00,0x00, // 0x3D =
    0x00,0x08,0x10,0x20,0x40,0x10,0x08,0x00, // 0x3E >
    0x00,0x38,0x44,0x04,0x08,0x00,0x08,0x00, // 0x3F ?
    0x00,0x38,0x4C,0x54,0x5C,0x40,0x38,0x00, // 0x40 @
    0x00,0x10,0x30,0x50,0x7C,0x50,0x50,0x00, // 0x41 A
    0x00,0x78,0x24,0x24,0x38,0x24,0x24,0x00, // 0x42 B
    0x00,0x38,0x44,0x40,0x40,0x44,0x38,0x00, // 0x43 C
    0x00,0x78,0x24,0x24,0x24,0x24,0x78,0x00, // 0x44 D
    0x00,0x78,0x44,0x40,0x58,0x40,0x40,0x00, // 0x45 E
    0x00,0x78,0x44,0x40,0x58,0x40,0x40,0x00, // 0x46 F
    0x00,0x38,0x44,0x40,0x4C,0x44,0x38,0x00, // 0x47 G
    0x00,0x50,0x50,0x78,0x50,0x50,0x50,0x00, // 0x48 H
    0x00,0x38,0x10,0x10,0x10,0x10,0x38,0x00, // 0x49 I
    0x00,0x18,0x08,0x08,0x08,0x28,0x18,0x00, // 0x4A J
    0x00,0x50,0x50,0x58,0x64,0x54,0x50,0x00, // 0x4B K
    0x00,0x40,0x40,0x40,0x40,0x40,0x78,0x00, // 0x4C L
    0x00,0x50,0x78,0x50,0x50,0x50,0x50,0x00, // 0x4D M
    0x00,0x50,0x70,0x50,0x50,0x50,0x50,0x00, // 0x4E N
    0x00,0x38,0x44,0x44,0x44,0x44,0x38,0x00, // 0x4F O
    0x00,0x78,0x24,0x24,0x38,0x20,0x20,0x00, // 0x50 P
    0x00,0x38,0x44,0x44,0x44,0x24,0x38,0x00, // 0x51 Q
    0x00,0x78,0x24,0x24,0x38,0x44,0x44,0x00, // 0x52 R
    0x00,0x38,0x40,0x38,0x04,0x44,0x38,0x00, // 0x53 S
    0x00,0x7C,0x10,0x10,0x10,0x10,0x10,0x00, // 0x54 T
    0x00,0x50,0x50,0x50,0x50,0x50,0x38,0x00, // 0x55 U
    0x00,0x50,0x50,0x50,0x50,0x28,0x10,0x00, // 0x56 V
    0x00,0x50,0x50,0x50,0x78,0x50,0x50,0x00, // 0x57 W
    0x00,0x50,0x50,0x28,0x10,0x28,0x50,0x00, // 0x58 X
    0x00,0x50,0x50,0x28,0x10,0x10,0x10,0x00, // 0x59 Y
    0x00,0x38,0x40,0x20,0x10,0x40,0x38,0x00, // 0x5A Z
    0x00,0x38,0x10,0x10,0x10,0x10,0x38,0x00, // 0x5B [
    0x00,0x40,0x20,0x10,0x08,0x04,0x00,0x00, // 0x5C \
    0x00,0x38,0x08,0x08,0x08,0x08,0x38,0x00, // 0x5D ]
    0x00,0x10,0x28,0x44,0x00,0x00,0x00,0x00, // 0x5E ^
    0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00, // 0x5F _
    0x00,0x08,0x04,0x00,0x00,0x00,0x00,0x00, // 0x60 `
    0x00,0x00,0x38,0x44,0x44,0x38,0x00,0x00, // 0x61 a
    0x00,0x40,0x40,0x78,0x44,0x44,0x38,0x00, // 0x62 b
    0x00,0x00,0x38,0x44,0x40,0x44,0x38,0x00, // 0x63 c
    0x00,0x00,0x38,0x44,0x44,0x44,0x78,0x00, // 0x64 d
    0x00,0x00,0x38,0x44,0x78,0x40,0x38,0x00, // 0x65 e
    0x00,0x10,0x30,0x50,0x70,0x10,0x10,0x00, // 0x66 f
    0x00,0x00,0x38,0x44,0x44,0x38,0x40,0x00, // 0x67 g
    0x00,0x40,0x40,0x78,0x44,0x44,0x44,0x00, // 0x68 h
    0x00,0x10,0x00,0x30,0x10,0x10,0x38,0x00, // 0x69 i
    0x00,0x08,0x00,0x18,0x08,0x08,0x28,0x00, // 0x6A j
    0x00,0x40,0x40,0x50,0x60,0x50,0x40,0x00, // 0x6B k
    0x00,0x38,0x10,0x10,0x10,0x10,0x10,0x00, // 0x6C l
    0x00,0x00,0x50,0x78,0x50,0x50,0x50,0x00, // 0x6D m
    0x00,0x00,0x50,0x78,0x50,0x50,0x50,0x00, // 0x6E n
    0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00, // 0x6F o
    0x00,0x00,0x78,0x24,0x24,0x24,0x24,0x00, // 0x70 p
    0x00,0x00,0x24,0x24,0x24,0x24,0x78,0x00, // 0x71 q
    0x00,0x00,0x50,0x78,0x50,0x50,0x10,0x00, // 0x72 r
    0x00,0x00,0x38,0x40,0x38,0x04,0x38,0x00, // 0x73 s
    0x00,0x10,0x10,0x78,0x10,0x10,0x08,0x00, // 0x74 t
    0x00,0x00,0x50,0x50,0x50,0x50,0x38,0x00, // 0x75 u
    0x00,0x00,0x50,0x50,0x50,0x28,0x10,0x00, // 0x76 v
    0x00,0x00,0x50,0x50,0x78,0x50,0x50,0x00, // 0x77 w
    0x00,0x00,0x50,0x28,0x10,0x28,0x50,0x00, // 0x78 x
    0x00,0x00,0x50,0x50,0x28,0x10,0x10,0x00, // 0x79 y
    0x00,0x00,0x38,0x20,0x10,0x20,0x38,0x00, // 0x7A z
    0x00,0x08,0x10,0x20,0x40,0x20,0x10,0x08, // 0x7B {
    0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10, // 0x7C |
    0x00,0x20,0x10,0x08,0x04,0x08,0x10,0x20, // 0x7D }
    0x00,0x28,0x10,0x28,0x00,0x00,0x00,0x00  // 0x7E ~

};

void OLED_Clear(void);

/************************** 内部辅助函数 **************************/
/**
 * @brief  OLED写入命令
 * @param  cmd: 要写入的命令
 * @retval HAL_StatusTypeDef: 传输状态
 */
static HAL_StatusTypeDef OLED_WriteCommand(uint8_t cmd)
{
    uint8_t buf[2] = {0x00, cmd}; // 控制字节=0x00（命令）+ 命令字节
    return HAL_I2C_Master_Transmit(OLED_I2C_HANDLE, OLED_I2C_ADDR, buf, 2, 100);
}

/**
 * @brief  OLED写入数据
 * @param  data: 要写入的数据
 * @retval HAL_StatusTypeDef: 传输状态
 */
static HAL_StatusTypeDef OLED_WriteData(uint8_t data)
{
    uint8_t buf[2] = {0x40, data}; // 控制字节=0x40（数据）+ 数据字节
    return HAL_I2C_Master_Transmit(OLED_I2C_HANDLE, OLED_I2C_ADDR, buf, 2, 100);
}

/**
 * @brief  设置OLED显示位置
 * @param  page: 页地址（0~7，对应64行，每页8行）
 * @param  col: 列地址（0~127）
 * @retval 无
 */
static void OLED_SetPos(uint8_t page, uint8_t col)
{
    OLED_WriteCommand(0xB0 + page);                  // 设置页地址（0xB0~0xB7）
    OLED_WriteCommand(0x00 + (col & 0x0F));          // 设置列地址低4位
    OLED_WriteCommand(0x10 + ((col >> 4) & 0x0F));   // 设置列地址高4位
}

/************************** 外部接口函数 **************************/
/**
 * @brief  OLED初始化（严格遵循数据手册8.3初始化序列）
 * @param  无
 * @retval HAL_StatusTypeDef: 初始化状态（HAL_OK/HAL_ERROR）
 */
HAL_StatusTypeDef OLED_Init(void)
{
    //HAL_Delay(20); // 电源稳定等待（数据手册要求VDD稳定后等待≥20ms）
    OLED_RESET(IO_ON);
    HAL_Delay(10);
    OLED_RESET(IO_OFF);
    HAL_Delay(100);  // 等待复位完成
    
    // 初始化命令序列（与数据手册8.3 Initial code完全一致）
    if (OLED_WriteCommand(0xAE) != HAL_OK) return HAL_ERROR; // 显示关闭
    if (OLED_WriteCommand(0xD5) != HAL_OK) return HAL_ERROR; // 设置显示时钟
    if (OLED_WriteCommand(0x90) != HAL_OK) return HAL_ERROR; // 105Hz（数据手册默认）
    if (OLED_WriteCommand(0xA8) != HAL_OK) return HAL_ERROR; // 多路复用比
    if (OLED_WriteCommand(0x3F) != HAL_OK) return HAL_ERROR; // 1/64 Duty（默认）
    if (OLED_WriteCommand(0xD3) != HAL_OK) return HAL_ERROR; // 显示偏移
    if (OLED_WriteCommand(0x00) != HAL_OK) return HAL_ERROR; // 偏移0
    if (OLED_WriteCommand(0x40) != HAL_OK) return HAL_ERROR; // 显示起始行
    if (OLED_WriteCommand(0x8D) != HAL_OK) return HAL_ERROR; // 电荷泵设置
    if (OLED_WriteCommand(0x14) != HAL_OK) return HAL_ERROR; // 开启电荷泵（必须）
    if (OLED_WriteCommand(0xAD) != HAL_OK) return HAL_ERROR; // 内部IREF设置
    if (OLED_WriteCommand(0x20) != HAL_OK) return HAL_ERROR; // 禁用内部IREF
    if (OLED_WriteCommand(0xA1) != HAL_OK) return HAL_ERROR; // 段重映射（默认）
    if (OLED_WriteCommand(0xC8) != HAL_OK) return HAL_ERROR; // COM扫描方向（反向）
    if (OLED_WriteCommand(0xDA) != HAL_OK) return HAL_ERROR; // COM硬件配置
    if (OLED_WriteCommand(0x12) != HAL_OK) return HAL_ERROR; // 交替COM引脚
    if (OLED_WriteCommand(0x81) != HAL_OK) return HAL_ERROR; // 对比度控制
    if (OLED_WriteCommand(0xB0) != HAL_OK) return HAL_ERROR; // 对比度值（数据手册默认）
    if (OLED_WriteCommand(0xD9) != HAL_OK) return HAL_ERROR; // 预充电周期
    if (OLED_WriteCommand(0x22) != HAL_OK) return HAL_ERROR; // 预充电周期设置
    if (OLED_WriteCommand(0xDB) != HAL_OK) return HAL_ERROR; // Vcomh电平设置
    if (OLED_WriteCommand(0x30) != HAL_OK) return HAL_ERROR; // Vcomh电平
    if (OLED_WriteCommand(0xA4) != HAL_OK) return HAL_ERROR; // 全显关闭（正常显示）
    if (OLED_WriteCommand(0xA6) != HAL_OK) return HAL_ERROR; // 正常显示（非反显）
    if (OLED_WriteCommand(0xAF) != HAL_OK) return HAL_ERROR; // 显示开启

    OLED_Clear(); // 清屏初始化
    return HAL_OK;
}

/**
 * @brief  OLED清屏（填充全黑）
 * @param  无
 * @retval 无
 */
void OLED_Clear(void)
{
    uint8_t page, col;
    for (page = 0; page < 8; page++) // 遍历8页
    {
        OLED_SetPos(page, 0);         // 设置当前页，列0
        for (col = 0; col < 128; col++) // 遍历128列
        {
            OLED_WriteData(0x00);     // 写入0x00（全黑）
        }
    }
}

/**
 * @brief  显示单个8x8字符
 * @param  page: 显示页（0~7）
 * @param  col: 起始列（0~127，每个字符占8列）
 * @param  ch: 要显示的ASCII字符（0x20~0x7E）
 * @retval 无
 */
void OLED_DisplayChar(uint8_t page, uint8_t col, uint8_t ch)
{
    if (page > 7 || col > 127 || ch < 0x20 || ch > 0x7E) return; // 参数校验

    uint8_t i;
    OLED_SetPos(page, col); // 设置显示位置
    for (i = 0; i < 8/*8*/; i++) // 写入8列数据（8x8点阵）
    
    {
         OLED_WriteData(OLED_Font8x8[(ch - 0x20) * 8 + i]);
        //OLED_WriteData(font_8x16[(ch - 0x20) ][ i]);
    }
}

/**
 * @brief  显示字符串（8x8点阵）
 * @param  page: 显示页（0~7）
 * @param  col: 起始列（0~127）
 * @param  str: 要显示的ASCII字符串（以'\0'结尾）
 * @retval 无
 */
void OLED_DisplayString(uint8_t page, uint8_t col, const char *str)
{
    while (*str != '\0')
    {
        OLED_DisplayChar(page, col, *str);
        col += 8; // 每个字符占8列，列地址偏移8
        if (col > 127) break; // 超出屏幕范围则停止
        str++;
    }
}